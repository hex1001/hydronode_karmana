

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PR1
VAR
	(*Заранее сформированные команды *)

	(*Для примера был взят модуль МВА с адресом 64, на первый канал был подключен датчик ДТС50М*)

	(*формат команды 03 протокола Modbus:
		1 байт: адрес устройства, к которому обращаемся
		1 байт: фунция чтения в нашем случае 3
		2 байта: адрес регистра, с которого производим чтение
		2 байта: число читаемых байт 
		2 байта: CRC
	 *)

	(*Формат ответа на команду:
		1 байт: адрес устройства, от которого ответ
		1 байт: фунция на которую отвечат устройство
		1 байт: число пересылаемых байт N от устройства
		N байт: ответ устройства 
		2 байта: CRC
	*)

	(*Читаем температуру измеренную первым каналом в целочисленном виде*)
	command1:ARRAY [0..16] OF BYTE:=	16#03,	16#03,	16#00,	16#02,	16#00,	16#01,	16#24,	16#28;			(*в десятичном виде*)
	command2:ARRAY [0..16] OF BYTE:= 	16#03,	16#03,	16#00,	16#02,	16#00,	16#01,	16#24,	16#28;		(*в шеснадцатиричном виде*)

	com_num1: PORTS := COM2;							(*Номер порта  на который подключено оборудование*)
	Settings1: COMSETTINGS;					(*Параметры порта *)
	COM_SERVICE1: COM_SERVICE;			(*Блок открытия и настройки порта *)
	com_ready1: BOOL;							(*Статус порта -  открыт/закрыт*)
	scb: send_command_bin;					(*Блок отправки ипиема*)
	rejim: BYTE;									(*режим работы контроллера*)
	ojid:TIME:=T#300ms;							(*Время ожидания ответа*)
	delay:TIME:=T#150ms;						(*Задержка между запросами*)
	er:WORD;										(*Ошибка работы блока отправки - приема*)
	timer:TON;										(*Таймер для реализации задерки между запросами*)
	er_tr:R_TRIG;									(*Тригер для подсчета задержек*)
	er_count:DWORD;							(*Число ошибок*)

	temp:WORD;									(*Значение температуры в целочисленном формате*)
	sdvig:WORD;									(*Сдвиг*)
	t:REAL;										(*Значение температуры вычесленное с учетом сдвига*)
	repead_scs: BYTE:=0;						(*Количество пройденных повторов*)
	repead_scs_count: BYTE:=2;					(*Число повторов в случае ошибки*)
	avaria: BOOL:=FALSE;
END_VAR

(* @END_DECLARATION := '0' *)
(* @TEXT_IMPLEMENTATION := 'ST' *)
(*****************************************************
Пример работы с библиотекой SysLibCom

формирование команды в двоичном виде
*****************************************************)


(*******************************************************
	Открываем порт
*******************************************************)

(*Открываем первый порт*)
IF COM_SERVICE1.ready=FALSE THEN
(*
	Номер порта (com_number):
	0 - RS-485
	1 - RS-232
	4 - RS-232 DEBUG
*)
	com_num1:=COM2;
(*
	Настройки порта (com_settings):
	byParity         - Режим проверки четности 0 = нет, 1 = нечет, 2 = чет
	byStopBits     - Кол-во стоповых бит 0 =один, 1=полтора , 2=два
	dwBaudRate   - Скорость обмена 4800, 9600, 19200, 38400, 57600, 115200 бит/с.
	dwBufferSize   - Не используется должно быть =0
	dwScan          - Не используется должно быть =0
	dwTimeout      - Не используется должно быть =0
	Port                - Номер порта в формате перечисления PORTS (com_number)		
*)
	Settings1.Port:=com_num1;
	Settings1.dwBaudRate:=9600;
	Settings1.byParity:=0;
	Settings1.dwTimeout:=0;
	Settings1.byStopBits:=0;
	Settings1.dwBufferSize:=0;
	Settings1.dwScan:=0;
(*
	Настройка и открытие порта (COM_SERVICE)
	Пока на выходе Ready не будет сигнал TRUE, стучимся в порт
	Порт открывается с настройками, указанными в com_settings, 
	а на вход Task подаются следующие значения:
	
	0 - Открытие и настройка порта в соответствии с настройками в структуре Settings
	1 - Изменение настроек уже открытого порта на настройки указанные в Settings
	2 - Закрытие порта, номер порта берется из Settings.Port																
*)
	COM_SERVICE1(Enable:=TRUE , Settings:=Settings1 , Task:=OPEN_TSK  );
	com_ready1:=FALSE;
ELSE
	COM_SERVICE1.Enable:=FALSE;
	com_ready1:=TRUE;
END_IF


(*******************************************************
	Работа с портом
*******************************************************)


IF (com_ready1=TRUE )THEN
	(*Порт открыт и инициализирован, теперь можно работать с портом*)
	(*Можно формировать команду и посылать ее в порт, после этого получать ответ от устройства*)
	(*Чтение и запись должны происходить в разных циклах контроллера, поэтому для чтения и записи используем оператор Case,
	который позволяет организовать разделение чтения и записи по циклам контроллера*)
	(*Переменная Status определяет что должен делать контроллер - слушать порт, либо послать выбранную команду*)
	(*Для отправки в порт команды можно заранее подготовить список используемых команд, либо написать дополнительный блок,
	который будет формировать команду и расчитывать контрольную сумму*)
	(*В данном примере используются две заранее сформированные команды*)


	CASE rejim OF
		0:
			(*Запрос целочисленного значения температуры*)
			scb(
				in:=TRUE ,
				command:=ADR(command1) ,
				len_command:=8 ,
				delay:=ojid ,
				port_number:=Settings1.Port ,
			);

			IF scb.ready  THEN
				er:=scb.errors;
				temp:=scb.rez;
				IF er=0 THEN
					temp:=scb.rez;
					repead_scs:=0;
					rejim:=1;
				ELSE
					temp:=0;
					(*Если есть ошибка, то вызываем блок повторно *)
					repead_scs:=repead_scs+1;
					IF repead_scs>repead_scs_count THEN
						(*если все попытки исчерпаны, вызываем опрос следующей команды*)
						rejim:=1;
						repead_scs:=0;
					ELSE
						rejim:=3;
					END_IF
				END_IF
				scb(in:=FALSE);
				timer(IN:=TRUE, PT:=delay );
			END_IF

		1:
			timer();
			IF timer.Q THEN
				timer(IN:=FALSE, PT:=T#200ms );
				rejim:=2;
			END_IF

		2:
			(*Запрос смещения*)
			scb(
				in:=TRUE ,
				command:=ADR(command2) ,
				len_command:=8 ,
				delay:=ojid ,
				port_number:=Settings1.Port ,
			);
	
			IF scb.ready  THEN
				er:=scb.errors;
				IF er=0 THEN
					sdvig:=scb.rez;
					repead_scs:=0;
					rejim:=3;
				ELSE
					(*Если есть ошибка, то вызываем блок повторно*)
					sdvig:=0;
					repead_scs:=repead_scs+1;
					IF repead_scs>repead_scs_count THEN
						rejim:=3;
						repead_scs:=0;
					ELSE
						rejim:=1;
					END_IF
				END_IF
				scb(in:=FALSE);
				timer(IN:=TRUE, PT:=delay );
			END_IF

		3:
			timer();
			IF timer.Q THEN
				timer(IN:=FALSE, PT:=T#0s );
				rejim:=0;
			END_IF
	END_CASE

	(*Если блок отправки закончил работу*)
	er_tr(CLK:=scb.ready );
	(* и  при этом на выходе есть ошибка*)
	IF er_tr.Q=TRUE AND scb.errors<>0 THEN
		(*Производим подсчет ошибок*)
		er_count:=er_count+1;
	END_IF

	IF scb.errors<>0 THEN
		avaria:=TRUE;
	ELSE
		avaria:=FALSE;
	END_IF
	(*Расчет реального значения температуры*)
	t:=temp/(EXPT(10,sdvig));

END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK send_command_bin

(*Входы функционального блока*)
VAR_INPUT
	(*Вход разрешающий работу блока*)
	in:BOOL:=FALSE;
	(*Указатель на массив байт в котором содержится пересылаемая команда*)
	command: POINTER TO BYTE;
	(*Размер отсылаемой команды*)
	len_command:WORD:=0;
	(*Задержка ответа*)
	delay: TIME := T#300ms;
	(*Номер порта в который отсылается команда и из которого принимаются данные*)
	port_number:ports:=0;
END_VAR

(*Выходы функционального блока*)
VAR_OUTPUT
	ready:BOOL:=FALSE;
	(*Результат принятый от устройства*)
	rez:WORD:=0;
	(*Ошибки*)
	errors: WORD:=0;
END_VAR

VAR
	(*Статус работы блока - 1: отправка данных, 0: прием данных*)
	status: BYTE:=1;
	(*Буфер чтения порта*)
	buf_otvet: ARRAY [0..7] OF BYTE ;
	(*Буфер в который собирается полный ответ от устройства*)
	otvet: ARRAY [0..15] OF BYTE ;
	(*Число принятых байт*)
	byte_read:DWORD;
	(*Число отправленных байт*)
	byte_wryte: DWORD;
	(*Таймер ожидания ответа*)
	T1: TON;
	(*Длина принятой команды*)
	l:DWORD:=0;
	(*Указатели, при поможи которых происходит выборка нужных данных из ответа *)
	p:POINTER TO BYTE;
	p1:POINTER TO BYTE;
	(*Тригер позволяющий определить фронт сигнала IN и выполнить инициализацию блока*)
	r1: R_TRIG;
	(*Инкремент*)
	i: DWORD;
END_VAR

(* @END_DECLARATION := '0' *)
(* @TEXT_IMPLEMENTATION := 'ST' *)
(*Анализируем запуск фуекционального блока*)
r1(CLK:=in );

(*Если пришел разрешающий сигнал запуска блока, то необходимо выполнить его инициализацию*)
IF(r1.Q)THEN
	(*Переводим блок в режим отправки команды*)
	status:=1;
	(*Статус блока - не готов*)
	ready:=FALSE;
END_IF

(*Если работа блока разрешена, то выполняем чтение и запись в порт с заданными параметрами*)
IF in=TRUE THEN

	CASE status OF
	(*Чтение буфера приема*)
	0:
		(*Вызываем таймер ожидания ответа*)
		T1();
		(*В переменную byte_read мы получаем число принятых байт при чтении порта*)
		byte_read:=SysComRead(port_number, ADR(buf_otvet), 8, 0);
		(*Если мы получили ответ от устройства, то принятую информацию собираем в более большой буфер ответа
		то есть собираем ответ в удобный для обработки формат*)
		IF byte_read>0 THEN
			FOR i:=0 TO byte_read-1 DO
				otvet[l+i]:=buf_otvet[i];
			END_FOR
			l:=l+byte_read;

			(*В данном месте программы необходимо реализовать обработку принятой из порта информации*)
			(*Дабы сильно не перегружать пример информации ниже используется подобие заглушки*)
			(*Известно что длина ответа на используемые в программе запросы сторого 8 байт*)
			(*Поэтому ниже производится анализ размера принятого ответа*)
			(*Как только приходит за отведенный интервал времени нужное количество байт, начинаем обработку принятой команды*)
			IF ( l=7) THEN
				(*Получили нужное количество байт*)
				(*Производим распаковку ответа и записываем его на выход блока*)
				p1:=ADR(otvet[4]);
				p:=ADR(rez);
				p^:=p1^;
				p1:=ADR(otvet[3]);
				p:=p+1;
				p^:=p1^;
				(*Останавливаем таймер ожидания ответа*)
				T1(IN:=FALSE, PT:=T#0s );
				(*Ошибок нет*)
				errors:=0;
				(*Значиния на выходе блока сформированы, их можно использовать в программе*)
				ready:=TRUE;
				(*Переводим блок в режим отправки запроса*)
				status:=1;
			END_IF
		END_IF

		(*Если таймер запущен и закончил работать, а нужного ответа нет, то формируем ошибки*)
		IF(T1.Q=TRUE AND T1.IN=TRUE )THEN
			(*Если ответ не пришел вооще, значит устройство не отвечает на запрос*)
			IF l=0 THEN
				(*Формируем ошибку нет связи*)
				errors:=81;
			ELSE
				(*Если ответ пришел, но не правильный, формируем ошибку CRC*)
				(*В данном блоке нет реального расчета CRC, это заглушка, чтобы понять что ответ не верный*)
				errors:=87;
			END_IF
			(*Останавливаем работу таймера ожидания ответа*)
			T1(IN:=FALSE, PT:=T#0s );
			(*В случае ошибки результат не меняем, дабы не нарушить работу других блоков*)
			(*При следующем опросе ошибка может пропасть и значение обновится на реальное*)
			rez:=rez;
			(*Выходы блока сформированы*)
			ready:=TRUE;
			(*Переводим блок в режим отправки команды*)
			status:=1;
		END_IF

	(*отправка команды  на запись*)
	1:
		(*Перед отправкой команды необходимо очистить буфер от предыдущего ответа*)
		FOR i:=0 TO 15 DO
			otvet[i]:=0;
		END_FOR

		(*и обнулить размер принятого ответа*)
		l:=0;
		(*В переменную byte_wryte мы получаем число отправленных байт*)
		byte_wryte:=SysComWrite(port_number, command, len_command, 0);
		(*Если запись в порт совершена - число бит команды совпадает с числом бит отправленных блоком отправки, то*)
		IF byte_wryte=len_command THEN
			(*Запускаем таймер ожидания ответа*)
			T1(IN:=TRUE, PT:=delay );
			T1();
			(*Выходы блока не сформированы*)
			ready:=FALSE;
			(*Переходим в режим чтения ответа от устройства*)
			status:=0;
		END_IF;

	END_CASE;

END_IF
END_FUNCTION_BLOCK
